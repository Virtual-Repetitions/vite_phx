defmodule Vite.View do
  @moduledoc """
  Help with View integration into Phoenix views
  """
  alias Vite.{Config, Chunk, ManifestReader}

  @doc """
  The snippet for `@vite/client` during development. Does nothing in :prod env.
  """
  @spec vite_client :: binary() | {:safe, binary()}
  def vite_client() do
    case Config.current_env() do
      :prod ->
        ""

      _ ->
        ~s(<script type="module" src="#{Config.dev_server_address()}/@vite/client"></script>)
        |> as_safe()
    end
  end

  @doc """
  Generate all links for an chunk struct in following order:

    1. styles to prevent FOUC
    2. main chunk script
    3. imports

  `
  <link phx-track-static rel="stylesheet" href="/assets/main.34asdfsf.css"/>
  <script type="module" crossorigin defer phx-track-static src="/assets/main.89abc777.js"></script>
  <link rel="modulepreload" href="/assets/_vendor.7788aaa.js">
  `
  """
  def entrypoint_snippet(%Chunk{isEntry: true} = chunk, descendent_chunks, opts \\ []) do
    prefix = Keyword.get(opts, :prefix, "/")

    css_files =
      ([chunk] ++ descendent_chunks)
      |> Enum.flat_map(& &1.cssfiles)
      |> Enum.map(&css_link(&1, prefix))
      |> Enum.join("\n")

    script = module_script(chunk.file, prefix)
    imports = Enum.map(descendent_chunks, &module_preload(&1.file, prefix)) |> Enum.join("\n")
    [css_files, script, imports] |> Enum.join("\n") |> as_safe()
  end

  def dev_entrypoint_snippet(entrypoint_name) do
    ~s(<script type="module" src="#{Config.dev_server_address()}/#{entrypoint_name}"></script>)
    |> as_safe()
  end

  @doc """
  Helper to generate HTML for module preloading, eg:

  `
  <link rel="modulepreload" href="/a-module.js">
  `
  """
  @spec module_preload(binary(), binary()) :: binary()
  def module_preload(href, prefix) do
    ~s(<link rel="modulepreload" href="#{prefix <> href}">)
  end

  @doc """
  Helper to generate HTML for a CSS link with static tracking:

  `
  <link phx-track-static rel="stylesheet" href="/some-styles.css"/>
  `
  """
  @spec css_link(binary(), binary()) :: binary()
  def css_link(href, prefix) do
    ~s{<link phx-track-static rel="stylesheet" href="#{prefix <> href}"/>}
  end

  @doc """
  Helper to generate HTML for JS modules

  Has automatic inclusion of `defer`, `crossorigin` and `phx-track-static` attributes.

  `
  <script type="module" crossorigin defer phx-track-static src="/module.js"></script>
  `
  """
  @spec module_script(binary(), binary()) :: binary()
  def module_script(src, prefix) do
    ~s{<script type="module" crossorigin defer phx-track-static src="#{prefix <> src}"></script>}
  end

  @doc """
  Helper to generate inlined Phoenix cache manifest to simplify integration with Javascript code.

  The manifest generated by `mix phx.digest` is stored in a global variable `window.PhxManifest`.
  Only works in :prod environment.
  """
  @spec inlined_phx_manifest() :: {atom(), binary()} | binary()
  def inlined_phx_manifest do
    case Config.current_env() do
      :prod ->
        manifest =
          ManifestReader.read_phx()
          |> Map.get("latest")
          |> Config.json_library().encode!(pretty: true)

        as_safe(["<script>window.PhxManifest = ", [manifest, ["</script>"]]])

      _ ->
        ""
    end
  end

  defp as_safe(s), do: {:safe, s}
end
